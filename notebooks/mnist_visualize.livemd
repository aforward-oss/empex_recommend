# Visualizing Your Data With Kino

```elixir
Mix.install([
  {:nx, "~> 0.5"},
  {:scidata, "~> 0.1"},
  {:explorer, "~> 0.5.0"},
  {:kino, "~> 0.9.3"}
])
```

## Load your data

We will be grabbing the [MNIST dataset](https://www.kaggle.com/datasets/hojjatk/mnist-dataset) from 
[scidata](https://github.com/elixir-nx/scidata) 
using [Scidata.MNIST.download()](https://github.com/elixir-nx/scidata/blob/master/lib/scidata/mnist.ex).  This is equivalent (I think) to [tfds](https://github.com/tensorflow/datasets).
Note that MNIST splits the images from the labels.

```elixir
{images, labels} = Scidata.MNIST.download()
```

In the dataset, we know the images are `28x28` (so 784 pixels) and 60k images.  We can also extract this information from the `images` data itself.

```elixir
{_, _, shape} = images
{dataset_size, _channels, h, w} = shape
num_features = h * w

{dataset_size, num_features}
```

Note that I called the pixels `num_features` as we use that matrix of 1s (dark) and 0s (light) to help us figure out the letter.  So we need to take our images `bin` and load them based on the `type`.  We then normlize them to 0s and 1s, as [the docs state](http://yann.lecun.com/exdb/mnist/) that `pixel 0 means background (white), 255 means foreground (black).` Finally, we describe the shape of the data as containing `{image, channel, height, width}`.

```elixir
{bin, type, _} = images

train_images =
  bin
  |> Nx.from_binary(type)
  |> Nx.divide(255.0)
  |> Nx.reshape(shape, names: [:images, :channels, :height, :width])
```

We can visualize the number using

```elixir
train_images[[images: 1]] |> Nx.to_heatmap()
```

Let's now add an Kino editor.

```elixir
form =
  Kino.Control.form(
    [
      index: Kino.Input.number("Image Index", default: 0)
    ],
    submit: "Render"
  )

Kino.render(form)

form
|> Kino.Control.stream()
|> Kino.animate(fn %{data: %{index: index}} ->
  train_images[[images: index]] |> Nx.to_heatmap()
end)
```
